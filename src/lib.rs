use eframe::egui;
use egui::{Color32, RichText};
use std::sync::Arc;
use egui_mobius_reactive::{Dynamic, Derived, ReactiveValue};

pub mod colors;
pub use colors::LogColors;

/// LogType
///
/// This enum is used to categorize the type of log entry
/// in the terminal widget. This is used to color code the
/// log entries.
///
/// The Default variant is used for general log entries
/// that do not fit into the other categories.
///
/// The Timestamp variant is used to indicate that the log
/// entry is a timestamped message.
///
/// The Slider, OptionA, OptionB, OptionC, CustomEvent, and
/// RunStop variants are used to categorize log entries
/// that are generated by the respective widgets.
///
/// The Slider variant is used for logs generated by the
/// slider widget.
///
/// The OptionA, OptionB, and OptionC variants are used for
/// logs generated by the option widgets.
///
/// The CustomEvent variant is used for logs generated by
/// custom events.
///
/// The RunStop variant is used for logs generated by the
/// run/stop widget.    
/// 
#[derive(Clone, Copy, PartialEq)]
pub enum LogType {
    Checkbox,
    Slider,
    OptionA,
    OptionB,
    OptionC,
    CustomEvent,
    RunStop,
    Default,
    Timestamp,
    Primary,
    Secondary,
}
/// Debug for LogType
/// 
/// This is used to display the LogType in the terminal widget
/// 
impl std::fmt::Debug for LogType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogType::Checkbox => write!(f, "Checkbox"),
            LogType::Primary => write!(f, "Primary"),
            LogType::Secondary => write!(f, "Secondary"),
            LogType::Slider => write!(f, "Slider"),
            LogType::OptionA => write!(f, "Option A"),
            LogType::OptionB => write!(f, "Option B"),
            LogType::OptionC => write!(f, "Option C"),
            LogType::CustomEvent => write!(f, "Custom Event"),
            LogType::RunStop => write!(f, "Run/Stop"),
            LogType::Default => write!(f, "Default"),
            LogType::Timestamp => write!(f, "Timestamp"),
        }
    }
}


#[derive(Clone)]
pub struct TerminalWidget {
    pub logs          : Dynamic<Vec<(String, LogType)>>,
    pub colors        : Dynamic<LogColors>,
    pub rich_text     : Derived<Vec<RichText>>,
    pub repaint       : egui::Context,
}

impl TerminalWidget {
    pub fn new(repaint: egui::Context, colors: LogColors) -> Self {
        let logs = Dynamic::new(Vec::new());
        let colors = Dynamic::new(colors);

        // Create derived rich text from logs and colors
        let logs_clone = logs.clone();
        let colors_clone = colors.clone();
        let deps = [
            Arc::new(logs.clone()) as Arc<dyn ReactiveValue>,
            Arc::new(colors.clone()) as Arc<dyn ReactiveValue>
        ];
        let rich_text = Derived::new(
            &deps,
            move || {
                let logs = logs_clone.get();
                let colors = colors_clone.get();
                logs.iter()
                    .rev()
                    .map(|(msg, log_type)| {
                        let color = match log_type {
                            LogType::Slider => colors.slider,
                            LogType::OptionA => colors.option_a,
                            LogType::OptionB => colors.option_b,
                            LogType::OptionC => colors.option_c,
                            LogType::CustomEvent => colors.custom_event,
                            LogType::Checkbox => colors.custom_event, // Use custom_event color for checkbox
                            LogType::RunStop => colors.run_stop_log,
                            LogType::Timestamp => colors.timestamp,
                            LogType::Default => Color32::WHITE,
                            LogType::Primary => colors.primary,
                            LogType::Secondary => colors.secondary,
                        };
                        RichText::new(msg).color(color)
                    })  
                    .collect()
            }); 

        Self {
            logs,
            colors,
            rich_text,
            repaint,

        }
    }


    /// Updates the color scheme for the terminal
    pub fn update_colors(&mut self, new_colors: LogColors) {
        // First update the logs to force a re-evaluation
        let logs = self.logs.get();
        self.logs.set(logs);

        // Then update the colors
        self.colors.set(new_colors);

        // Force a repaint to show the changes
        self.repaint.request_repaint();
    }
}
